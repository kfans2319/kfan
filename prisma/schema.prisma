generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model User {
  id                    String             @id
  username              String             @unique
  displayName           String
  email                 String?            @unique
  passwordHash          String?
  googleId              String?            @unique
  avatarUrl             String?
  bannerImageUrl        String?            // Added field for banner image
  bio                   String?
  balance               Decimal            @default(0.0)
  earningsBalance       Decimal            @default(0.0)
  createdAt             DateTime           @default(now())
  isAdmin               Boolean            @default(false)
  isVerified            Boolean            @default(false)
  verificationStatus    VerificationStatus @default(NONE)
  verificationPose      String?            // Stores the randomly assigned pose for verification
  selfieImageUrl        String?
  idImageUrl            String?
  verificationSubmittedAt DateTime?
  verificationProcessedAt DateTime?
  verificationProcessedById String?
  verificationProcessor User?              @relation("VerificationProcessor", fields: [verificationProcessedById], references: [id])
  processedVerifications User[]            @relation("VerificationProcessor")
  bookmarks             Bookmark[]
  comments              Comment[]
  following             Follow[]           @relation("Following")
  followers             Follow[]           @relation("Followers")
  likes                 Like[]
  issuedNotifications   Notification[]     @relation("Issuer")
  receivedNotifications Notification[]     @relation("Recipient")
  posts                 Post[]
  sessions              Session[]
  createdTiers          SubscriptionTier[] @relation("CreatorTiers")
  subscriptions         Subscription[]     @relation("Subscriber")
  bankInformation       BankInformation?
  payoutRequests        PayoutRequest[]    @relation("UserPayoutRequests")
  processedPayouts      PayoutRequest[]    @relation("PayoutProcessor")
  receivedEarnings      CreatorEarning[]   @relation("CreatorEarnings")
  paidSubscriptions     CreatorEarning[]   @relation("SubscriberPayments")

  @@map("users")
}

model Session {
  id        String   @id
  userId    String
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Follow {
  followerId  String
  followingId String
  follower    User   @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  following   User   @relation("Followers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@map("follows")
}

model Post {
  id                  String         @id @default(cuid())
  content             String
  userId              String
  createdAt           DateTime       @default(now())
  isPublic            Boolean        @default(false)
  bookmarks           Bookmark[]
  comments            Comment[]
  likes               Like[]
  linkedNotifications Notification[]
  attachments         Media[]
  user                User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("posts")
}

model Media {
  id        String    @id @default(cuid())
  postId    String?
  type      MediaType
  url       String
  createdAt DateTime  @default(now())
  post      Post?     @relation(fields: [postId], references: [id])

  @@map("post_media")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  userId    String
  postId    String
  createdAt DateTime @default(now())
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("comments")
}

model Like {
  userId String
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("likes")
}

model Bookmark {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@map("bookmarks")
}

model Notification {
  id          String           @id @default(cuid())
  recipientId String
  issuerId    String
  postId      String?
  type        NotificationType
  read        Boolean          @default(false)
  createdAt   DateTime         @default(now())
  issuer      User             @relation("Issuer", fields: [issuerId], references: [id], onDelete: Cascade)
  post        Post?            @relation(fields: [postId], references: [id], onDelete: Cascade)
  recipient   User             @relation("Recipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model SubscriptionTier {
  id            String         @id @default(cuid())
  name          String
  description   String?
  price         Decimal
  duration      Int            @default(1) // Duration in months
  creatorId     String
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  creator       User           @relation("CreatorTiers", fields: [creatorId], references: [id], onDelete: Cascade)
  subscriptions Subscription[]

  @@map("subscription_tiers")
}

model Subscription {
  id           String           @id @default(cuid())
  subscriberId String
  tierId       String
  expiresAt    DateTime
  autoRenew    Boolean          @default(true)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  subscriber   User             @relation("Subscriber", fields: [subscriberId], references: [id], onDelete: Cascade)
  tier         SubscriptionTier @relation(fields: [tierId], references: [id], onDelete: Cascade)
  earnings     CreatorEarning[]

  @@unique([subscriberId, tierId])
  @@map("subscriptions")
}

enum MediaType {
  IMAGE
  VIDEO
}

enum NotificationType {
  LIKE
  FOLLOW
  COMMENT
}

enum VerificationStatus {
  NONE
  PENDING
  APPROVED
  REJECTED
}

enum PayoutRequestStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum PayoutMethod {
  BANK
  ETH_WALLET
}

enum BankType {
  DOMESTIC
  INTERNATIONAL
}

model BankInformation {
  id                   String   @id @default(cuid())
  userId               String   @unique
  bankType             BankType @default(DOMESTIC)
  bankName             String
  accountNumber        String
  routingNumber        String?  // Optional for international banks
  accountHolderName    String
  // International bank fields
  swiftCode            String?
  iban                 String?
  bankAddress          String?
  accountHolderAddress String?
  intermediaryBankName String?
  intermediaryBankSwiftCode String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("bank_information")
}

model PayoutRequest {
  id           String              @id @default(cuid())
  userId       String
  amount       Decimal
  status       PayoutRequestStatus @default(PENDING)
  payoutMethod PayoutMethod        @default(BANK)
  ethWalletAddress String?         
  requestedAt  DateTime            @default(now())
  processedAt  DateTime?
  processorId  String?
  notes        String?
  user         User                @relation("UserPayoutRequests", fields: [userId], references: [id], onDelete: Cascade)
  processor    User?               @relation("PayoutProcessor", fields: [processorId], references: [id])

  @@map("payout_requests")
}

model CreatorEarning {
  id             String       @id @default(cuid())
  creatorId      String
  subscriberId   String
  subscriptionId String
  amount         Decimal
  platformFee    Decimal
  earnedAt       DateTime     @default(now())
  creator        User         @relation("CreatorEarnings", fields: [creatorId], references: [id], onDelete: Cascade)
  subscriber     User         @relation("SubscriberPayments", fields: [subscriberId], references: [id], onDelete: Cascade)
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@map("creator_earnings")
}
