# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. Please do not delete, edit or create .env files. if you need to add something into the .env file tell me what to add and i will copy and paste it in myself.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```
venv/bin/python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```
venv/bin/python ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Use it.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.
- When implementing financial features like banking information, make sure to include proper admin interfaces to view and manage this data.
- Maintain visual consistency across related UI components (dashboards, forms, tables) to create a professional and cohesive user experience.
- When implementing responsive UI designs, use a mobile-first approach with appropriate breakpoints (sm, md, lg). For optimal user experience, adapt layouts (not just sizing) - use cards on mobile instead of tables, simpler navigation patterns, and ensure touch targets are at least 44px tall/wide.
- For mobile navigation components like tabs or menus, consider using icon-based interfaces with minimal text on very small screens. Use vertical stacking (icon above label) to maximize space and improve readability for critical navigation elements.
- When designing tab navigation for mobile screens, increase the height of tab buttons (to at least 14px), reduce horizontal padding, use simplified labels, and ensure proper spacing between tabs. Consider using a vertical layout for icons and text to improve touch targets and readability.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When using Prisma's _count in select queries, explicitly include all the fields you need to count (e.g., posts, followers) to avoid undefined values that can result in NaN displays
- In TypeScript, do not include file extensions (.ts, .tsx) in import statements unless the 'allowImportingTsExtensions' option is enabled in tsconfig.json
- When adding new fields to a Prisma schema, make sure to run `npx prisma generate` to update TypeScript types before using the new fields
- When adding self-referential relations in Prisma, ensure the field names and relation names are correctly defined to avoid circular references
- When using Shadcn UI components, make sure all required UI components are created in the components/ui directory before using them in other components
- When installing npm packages with dependency conflicts, use the --legacy-peer-deps flag to bypass peer dependency requirements
- When working with Next.js's useSearchParams hook, always handle the case where searchParams might be null using optional chaining or conditional checks
- Before using Shadcn UI components like Table, create them first using `npx shadcn-ui@latest add table` or manually add the component files to the components/ui directory
- When working with Prisma Decimal fields in Next.js, always convert them to strings before passing from Server Components to Client Components to avoid serialization errors
- When implementing financial features with percentage-based calculations, store both the gross amount and the fee amount separately in the database to maintain an audit trail and ensure transparency
- When working with multiple balance types (e.g., payment balance vs. earnings balance), ensure all API routes and components consistently use the correct balance field for their specific purpose
- For API routes that make complex database queries, implement a multi-tiered timeout strategy with graceful degradation: use shorter timeouts, break operations into smaller chunks, implement effective caching, exclude non-essential data, and provide fallback responses rather than failing completely
- When using icon libraries like Lucide React, ensure all icons used in components are explicitly imported, especially when adding new icons during development to prevent runtime "is not defined" errors
- When dealing with cryptocurrency payments in production applications, always implement proper transaction verification and security measures such as recipient address validation, transaction confirmation, and timeout handling
- When implementing dropdowns, modals, or popup menus, always include click-outside detection to dismiss them for better UX. This can be implemented using the useRef hook to reference the container element and a useEffect to add a document-level click listener that closes the element when clicks occur outside the referenced element.
- When implementing wallet connection features for Web3 applications, always provide a way for users to reconnect or switch wallets by using MetaMask's wallet_requestPermissions API, which allows users to select from their available accounts.
- When implementing payout functionality for multiple payment methods, ensure your schema properly handles different payment types (e.g., bank accounts vs cryptocurrency wallets) with appropriate validation for each method.
- When implementing a payout rejection flow, always refund the amount back to the user's balance using a database transaction to ensure both the status update and balance adjustment happen atomically.
- For admin interfaces managing financial transactions, implement proper status workflows that include validations, relevant data display based on payment method, and appropriate actions for each status state.
- When implementing a profile banner image feature, position the avatar to overlap the bottom edge of the banner for a modern social media appearance, and provide a gradient fallback for users without a banner image.
- When working with database schema changes that might not be immediately reflected in TypeScript types, use TypeScript workarounds like type assertions (as any) and raw SQL queries to ensure functionality while maintaining type safety elsewhere.
- For image upload components, implement proper aspect ratio cropping (16:9 for banners, 1:1 for avatars) to ensure consistent visual appearance across the application.
- When positioning interactive elements (like buttons) on top of banner images or variable-colored backgrounds, use a combination of semi-transparent backgrounds (`bg-background/95`), backdrop blur effects (`backdrop-blur-sm`), and explicit hover states (`hover:opacity-90`) instead of relying on the default component styling to ensure consistent visibility and behavior. Avoid hover effects that change background colors which can make text disappear against certain backgrounds.
- When implementing user verification systems, enhance security by requiring users to perform random poses in their verification selfies (e.g., "Touch your right ear with your left hand"). This helps prevent fraud by ensuring verification photos are taken in real-time rather than using pre-existing images. Make sure to store the assigned pose and display it in the admin verification interface so admins can confirm the user followed instructions.
- When implementing authentication-dependent data fetching in React applications, ensure proper auth state synchronization by: 1) Making the query execution conditional with the `enabled` option, 2) Including the authentication state in the query key for reactivity, 3) Adding an explicit refetch trigger when authentication state changes using useEffect, 4) Always sending credentials with API requests, and 5) Adding proper error handling for authentication failures to provide clear feedback to users. This comprehensive approach prevents the common "need to refresh after login" issue by ensuring data fetching respects the authentication lifecycle.
- When handling fresh login states in web applications, implement a comprehensive solution that includes: 1) Tracking session timestamps to detect fresh logins, 2) Using a ref object for stable state access during async operations, 3) Creating special API routes or endpoints for fresh login requests, 4) Implementing cache-busting for authentication-dependent requests, 5) Using a multi-tiered refetch strategy with immediate refetch for fresh logins, standard refetch for state changes, and automatic retry for auth errors, and 6) Setting proper Next.js cache directives like 'force-dynamic' to prevent stale session data. This approach ensures data loads immediately after login without requiring a page refresh.
- When fetching nested data for client-side components, implement defensive programming techniques such as: 1) Always include null/undefined checks when accessing nested properties (e.g., `post.likes?.length > 0` instead of `post.likes.length > 0`), 2) Provide fallback defaults for optional data, 3) Ensure API routes include all data needed by client components or provide reasonable defaults, 4) Use TypeScript to properly type optional fields, and 5) Consider implementing a data normalization layer that ensures consistent data shape regardless of the data source. This comprehensive approach prevents runtime errors when data structures change or certain properties are conditionally included.
- When automating user data imports and content creation in a Next.js + Prisma application, it's better to use Prisma directly rather than working through API routes for bulk operations. This approach is more efficient, avoids the overhead of HTTP requests, and gives you more direct control over the database operations. Additionally, for image uploads in a development/testing environment, consider directly copying files to the public directory and storing the appropriate URLs in the database, rather than using the full upload mechanism which may involve third-party services.
- When creating subscription tiers for users, implement a tiered pricing structure with different features for each tier. Create a logical progression with increasing prices and durations, where higher-priced tiers have longer subscription periods (e.g., 4-12 months). This strategy increases perceived value and encourages longer-term commitments from premium subscribers.
- When creating user-generated content in a subscription-based platform, ensure a mix of public and subscriber-only content. This provides free content for marketing and user acquisition while still incentivizing subscriptions for premium content. A good ratio might be 60% public and 40% subscriber-only content.

## Upload Thing URL Format Lesson
When working with UploadThing URLs, especially for videos from the t8x8bguwl4.ufs.sh domain:
1. Always test the URL format directly to ensure it's accessible (returns 200 status)
2. For videos on t8x8bguwl4.ufs.sh, use the /f/{videoId} format instead of /a/t8x8bguwl4/{videoId}
3. Alternative domains like utfs.io may provide more reliable access using the same fileId
4. Create a server-side proxy to handle CORS issues for cross-origin media files
5. Always provide multiple source formats in video elements for better compatibility
6. Test URL variations with a simplified test script before implementing in production code

When storing media URLs in the database:
1. For t8x8bguwl4.ufs.sh video files, store the `/f/{videoId}` format
2. For images, the standard `/a/t8x8bguwl4/{imageId}` format usually works fine
3. Consider storing both formats or implementing URL transformation logic in the getter

# Scratchpad

## Current Task: Fixing UploadThing Video URL Formats and Playback

### Task Description
Fix video playback issues with UploadThing URLs, especially for the problematic URL pattern:
`https://t8x8bguwl4.ufs.sh/a/t8x8bguwl4/5e7d80aa-602b-4dd3-9298-f9f173a8d4ac-p7ovvf.mp4`

### Implementation
We implemented a comprehensive solution that:

1. Created a server-side media proxy to handle CORS issues
2. Added specific handling for problematic video ID
3. Identified the correct URL formats that actually work:
   - `https://t8x8bguwl4.ufs.sh/f/{videoId}`
   - `https://utfs.io/f/{videoId}`
4. Enhanced video element with multiple sources and formats
5. Added a debug page for testing video URLs
6. Created a test script to verify URL formats

### Solution Approach
The key findings:
- UploadThing URLs in `/a/` format with domain-specific paths don't work reliably
- The `/f/` format without the domain-specific path works best
- A server-side proxy helps avoid CORS issues, but direct URLs work when properly formatted
- Testing multiple URL variations gives the best chance of successful playback

### Lessons Learned
- For UploadThing videos, especially from `t8x8bguwl4.ufs.sh` domain:
  - Use `/f/{videoId}` format instead of `/a/t8x8bguwl4/{videoId}`
  - Try multiple URL variations including different domains (utfs.io)
  - A media proxy can help avoid CORS issues
  - Test URL accessibility before attempting to play videos
  - Extract the file ID from problematic URLs and construct proper formats

# Lessons

## Upload Thing URL Format Lesson
When working with UploadThing URLs, especially for videos from the t8x8bguwl4.ufs.sh domain:
1. Always test the URL format directly to ensure it's accessible (returns 200 status)
2. For videos on t8x8bguwl4.ufs.sh, use the /f/{videoId} format instead of /a/t8x8bguwl4/{videoId}
3. Alternative domains like utfs.io may provide more reliable access using the same fileId
4. Create a server-side proxy to handle CORS issues for cross-origin media files
5. Always provide multiple source formats in video elements for better compatibility
6. Test URL variations with a simplified test script before implementing in production code

When storing media URLs in the database:
1. For t8x8bguwl4.ufs.sh video files, store the `/f/{videoId}` format
2. For images, the standard `/a/t8x8bguwl4/{imageId}` format usually works fine
3. Consider storing both formats or implementing URL transformation logic in the getter